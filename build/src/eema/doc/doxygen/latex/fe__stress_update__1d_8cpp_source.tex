\hypertarget{fe__stress_update__1d_8cpp_source}{}\section{fe\+\_\+stress\+Update\+\_\+1d.\+cpp}
\label{fe__stress_update__1d_8cpp_source}\index{src/eema/src/\+Materials/\+Stress\+Update/fe\+\_\+stress\+Update\+\_\+1d.\+cpp@{src/eema/src/\+Materials/\+Stress\+Update/fe\+\_\+stress\+Update\+\_\+1d.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include"\hyperlink{functions_8h}{functions.h}"}
00002 
00003 \textcolor{keyword}{using namespace }\hyperlink{namespace_eigen}{Eigen};
00004 
\Hypertarget{fe__stress_update__1d_8cpp_source_l00006}\hyperlink{fe__stress_update__1d_8cpp_a94c1b672863e28bc2c70d08726939929}{00006} VectorXd \hyperlink{fe__stress_update__1d_8cpp_a94c1b672863e28bc2c70d08726939929}{fe\_stressUpdate\_1d}(VectorXd dndx, VectorXd dndy, VectorXd dndz, VectorXd u\_e, \textcolor{keywordtype}{
      int} opt, MatrixXd nodes)\{
00007 
00008     MatrixXd F = MatrixXd::Zero(3,3); \textcolor{comment}{// deformation gradient}
00009     F = \hyperlink{functions_8h_ae50379f74802347e04dbc022897f9cb0}{fe\_calDefGrad}(dndx,dndy,dndz,u\_e);
00010     \textcolor{keywordtype}{double} defJacobian = F.determinant();
00011 
00012     MatrixXd C = F.transpose()*F;
00013 
00014     VectorXd dir\_truss = VectorXd::Zero(3);
00015     dir\_truss << (nodes(1,1)-nodes(0,1)) , (nodes(1,2)-nodes(0,2)), (nodes(1,3)-nodes(0,3));
00016     VectorXd deformed\_truss = C*dir\_truss;
00017 
00018     \textcolor{keywordtype}{double} lambda\_tmp = dir\_truss.dot(deformed\_truss);
00019     \textcolor{keywordtype}{double} lambda = sqrt(lambda\_tmp);
00020     \textcolor{comment}{// Until this point, deformation along the truss direction was calculated. now its time to calculate
       the stress in this dirn.}
00021 
00022     VectorXd sigma = VectorXd::Zero(6); \textcolor{comment}{//piola-kirchhoff stress-vector}
00023     VectorXd cauchy\_sigma = VectorXd::Zero(6);
00024 
00025     std::string model;
00026     model = \hyperlink{functions_8h_a34d6fb85943d945b7e8600d2ef4220d0}{fe\_get\_model}(opt);
00027 
00028     \textcolor{keywordflow}{if}(model==\textcolor{stringliteral}{"simple\_elastic"})\{ \textcolor{comment}{// Isotropic truss element}
00029         \textcolor{keywordtype}{double} E = \hyperlink{functions_8h_af7ffbad6dfcc99fc88b130c1a7b1720a}{fe\_get\_mats}(opt,1);
00030         cauchy\_sigma(0) = E*log(lambda);
00031         \textcolor{comment}{// std::cout<<"Stretch is: "<<lambda<<"\(\backslash\)n";}
00032     \}
00033 
00034     \textcolor{keywordflow}{if}(model==\textcolor{stringliteral}{"mooney-rivlin\_hyperelastic"})\{
00035         \textcolor{keywordtype}{double} c\_1 = \hyperlink{functions_8h_af7ffbad6dfcc99fc88b130c1a7b1720a}{fe\_get\_mats}(opt,3);
00036         \textcolor{keywordtype}{double} c\_2 = \hyperlink{functions_8h_af7ffbad6dfcc99fc88b130c1a7b1720a}{fe\_get\_mats}(opt,4);
00037         cauchy\_sigma(0) = ((2*c\_1) + ((2*c\_2)/(lambda)))*((pow(lambda,2))-(1/lambda));
00038     \}
00039 
00040     MatrixXd stress\_transform\_mat = \hyperlink{functions_8h_aa41c40dffea4251a07a8a3f5062f47ae}{fe\_calTransformation}(nodes,1); \textcolor{comment}{// Stress
       transformation from truss CSYS to element CSYS.}
00041 
00042 
00043     VectorXd tmp\_cauchy\_sigma = stress\_transform\_mat.transpose()*cauchy\_sigma; \textcolor{comment}{// Cauchy stress vector in
       element CSYS.}
00044 
00045     MatrixXd element\_cauchy\_sigma = MatrixXd::Zero(3,3);
00046     element\_cauchy\_sigma(0,0) = tmp\_cauchy\_sigma(0);
00047     element\_cauchy\_sigma(1,1) = tmp\_cauchy\_sigma(1);
00048     element\_cauchy\_sigma(2,2) = tmp\_cauchy\_sigma(2);
00049     element\_cauchy\_sigma(0,1) = tmp\_cauchy\_sigma(3);
00050     element\_cauchy\_sigma(1,0) = tmp\_cauchy\_sigma(3);
00051     element\_cauchy\_sigma(1,2) = tmp\_cauchy\_sigma(4);
00052     element\_cauchy\_sigma(2,1) = tmp\_cauchy\_sigma(4);
00053     element\_cauchy\_sigma(0,2) = tmp\_cauchy\_sigma(5);
00054     element\_cauchy\_sigma(2,0) = tmp\_cauchy\_sigma(5);
00055 
00056     \textcolor{comment}{// fe\_display\_matrix(element\_cauchy\_sigma);}
00057 
00058 
00059     MatrixXd F\_inv = F.inverse();
00060     MatrixXd pk\_S = MatrixXd::Zero(3,3);
00061     pk\_S = defJacobian*F\_inv*element\_cauchy\_sigma*F\_inv.transpose();
00062 
00063     sigma(0) = pk\_S(0,0);
00064     sigma(1) = pk\_S(1,1);
00065     sigma(2) = pk\_S(2,2);
00066     sigma(3) = pk\_S(0,1);
00067     sigma(4) = pk\_S(1,2);
00068     sigma(5) = pk\_S(0,2);
00069 
00070     \textcolor{comment}{/*sigma(0) = element\_cauchy\_sigma(0,0);}
00071 \textcolor{comment}{    sigma(1) = element\_cauchy\_sigma(1,1);}
00072 \textcolor{comment}{    sigma(2) = element\_cauchy\_sigma(2,2);}
00073 \textcolor{comment}{    sigma(3) = element\_cauchy\_sigma(0,1);}
00074 \textcolor{comment}{    sigma(4) = element\_cauchy\_sigma(1,2);}
00075 \textcolor{comment}{    sigma(5) = element\_cauchy\_sigma(0,2);*/}
00076 
00077     \textcolor{keywordflow}{return} sigma;
00078 \}
\end{DoxyCode}
